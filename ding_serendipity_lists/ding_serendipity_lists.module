<?php

/**
 * @file
 * This serendipity plugin module provides serendipity based on user lists
 * and previous loans
 */

/**
 * Implements hook_admin_settings_alter().
 */
function ding_serendipity_lists_form_ding_frontpage_admin_settings_alter(&$form, &$form_state, $form_id) {
  $form['ding_serendipity_lists'] = array(
    '#type' => 'fieldset',
    '#title' => t('Ding serendipity lists front page settings'),
    // TODO What is the point of this field?
    '#weight' => 5,
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
  $form['ding_serendipity_lists']['ding_frontpage_serendipity_search_string'] = array(
    '#type' => 'textfield',
    '#title' => t('Front page serendipity fallback search string'),
    '#default_value' => variable_get('ding_frontpage_serendipity_search_string', ''),
    '#size' => 160,
    '#maxlength' => 300,
  );
}

/**
 * Implements hook_serendipity_info().
 */
function ding_serendipity_lists_serendipity_info() {
  $items = array();

  if (module_exists('ting_openlist')) {
    $items['ting_objects_adhr'] = array(
      'title' => 'Ting objects via openlist ADHR service',
      'description' => 'Call ADHR service on the current object',
      'keys' => array('ting_object', 'frontpage'),
    );
  }

  $items += array(
    'frontpage_search' => array(
      'title' => t('Front page fallback content'),
      'description' => t('Allow the library admin to enter a search string which pulls materials to be pushed to the front page.'),
      'keys' => array('ting_object', 'frontpage'),
    ),
    'loan_adhl' => array(
      'title' => t('ADHL on random loan items'),
      'description' => t('Check a random current loan via ADHL for serendipity.'),
      'keys' => array('ting_object', 'frontpage'),
    ),
    'author_from_lists' => array(
      'title' => t('Objects matching random author from lists'),
      'description' => t('Objects matching random author from lists. Combined with tid'),
      // TODO: What does "Combined with tid" mean?
      'keys' => array('ting_object', 'frontpage'),
    ),
    // TODO: Since these functions are obsolete it would be good to have them
    // contained in a separate module which does not have to be enabled on future
    // sites and can be deleted once we drop backwards compatibility.
    'followed_terms_nodes' => array(
      'title' => t('p1 / obsolete / Nodes matching followed terms'),
      'description' => t('Nodes matching followed terms. Filter by <em>bundle</em>'),
      'keys' => array('node', 'frontpage'),
    ),
    'followed_terms_ting_objects' => array(
      'title' => t('p1 / obsolete / Ting objects matching followed terms'),
      'description' => t('Ting objects matching a random followed term.'),
      'keys' => array('ting_object', 'frontpage'),
    ),
  );

  return $items;
}

/**
 * Implements hook.
 * TODO This is a callback - not a hook?
 */
function ding_serendipity_lists_ting_objects_adhr_serendipity_add($context) {
  global $user;
  $results = array();

  // Only provider users has current loans.
  if (!ding_user_is_provider_user($user)) {
    return $results;
  }

  // Get the element ids, values and weights from all the elements in the
  // ratings list.
  // TODO: This adds a dependency to the rating system?
  $query = db_select('eck_ding_type', 'l');
  $query->join(
    'field_data_field_list_type', 'fdflt',
    'fdflt.entity_id = l.id AND fdflt.field_list_type_value = :rating',
    array(':rating' => DING_ENTITY_RATING_LIST)
  );
  $query->join(
    'field_data_field_list_objects', 'fdflo',
    'fdflo.entity_id = l.id'
  );
  $query->join(
    'field_data_field_value', 'fdfv',
    'fdfv.entity_id = fdflo.field_list_objects_target_id'
  );
  $query->join(
    'field_data_field_weight', 'fdfw',
    'fdfw.entity_id = fdflo.field_list_objects_target_id'
  );
  $query
    ->fields('fdflo', array('field_list_objects_target_id'))
    ->fields('fdfv', array('field_value_value'))
    ->fields('fdfw', array('field_weight_value'))
    ->condition('l.type', 'ding_list')
    ->condition('l.uid', $user->uid);

  // Put all the element ids with a weight of 5 in the five_ids array, and all
  // ting_object ids in the item_ids.
  $five_ids = array();
  $item_ids = array();
  foreach ($query->execute()->fetchAll() as $row) {

    if ($row->field_weight_value == 5) {
      $five_ids[] = $row->field_list_objects_target_id;
    }
    $item_ids[] = $row->field_value_value;
  }

  // Select 4 random ids of all the rated objects.
  // TODO: Why 4?
  shuffle($five_ids);
  $five_ids = array_slice($five_ids, 0, 4);
  $buffer = entity_load('ding_type', $five_ids);
  
  // Get other suggestions from openlist.
  foreach ($buffer as $item) {
    // TODO: What does the value actually represent at this point?
    $value = ding_list_get_list_element_value($item);
    try {
      $openlist_items = ding_provider_invoke('openlist', 'request', 'callModule', array(
        'TingObjectRating',
        'getSuggestion',
        array($value),
      ));
    
      // Only include items not rated by the user.
      foreach ($openlist_items as $openlist_item) {
        $id = ding_list_convert_cql($openlist_item);
        if (!in_array($id, $item_ids)) {
          // TODO If each result only contain two values why is this not a map
          // of value to id? This could make the subsequent code clearer.
          // Otherwise please use string keys.
          $results[] = array(
            $id,
            $value,
          );
        }
      }
    }
    catch (Exception $e) {
      // NOP
    }
  }

  foreach ($results as &$result) {
    $obj = ding_entity_load($result[1], 'ting_object');

    $title = l($obj->getTitle(), "ting/object/" . $result[1]);

    $result = array(
      'type' => 'ting_object',
      'id' => $result[0],
      'info' => array(
        'description' => t('Because other people who also liked !title liked this.', array('!title' => $title)),
      ),
    );
  }

  return $results;
}

/**
 * Find objects matching some random author from the user lists.
 *
 * @param array $context
 *   Serendipity context.
 *
 * @return array
 *   An array with serendipity items.
 */
function ding_serendipity_lists_frontpage_search_serendipity_add($context) {
  $results = array();
  if ($query = variable_get('ding_frontpage_serendipity_search_string', '')) {
    // Fetch search results.
    $results = ding_serendipity_do_search($query);
    if ($results) {
      // Append info.
      foreach ($results as & $item) {
        $item['info'] = array(
          'description' => t('Recommended by the library.'),
        );
      }
    }
  }
  return $results;
}

/**
 * Select random objects.
 *
 * From current loans and fetch recommended objecs via ADHL service.
 *
 * @param array $context
 *   Serendipity context
 *
 * @return array
 *   An array with serendipity items.
 */
function ding_serendipity_lists_loan_adhl_serendipity_add($context) {
  global $user;
  $results = array();

  // Only provider users has current loans.
  // TODO What does this have to do with path checking?
  if (!ding_user_is_provider_user($user) || strpos($context['path'], 'taxonomy/term') !== FALSE) {
    return $results;
  }

  // TODO Please use ding_provider_invoke
  // This creates a dependency to ding_provider. This is not declared.
  $loans = ding_provider_invoke_page('loan', 'list', $user);

  if (empty($loans)) {
    // Get user loan history.
    $user_history_list = ding_list_get_lists(DING_LIST_TYPE_LOAN_HISTORY);
    $history_list = current($user_history_list);
    $list_elements = ding_list_load_elements($history_list);
    foreach ($list_elements as $element) {
      $ting_object_id = ding_list_get_list_element_value($element);
      // @todo: Brond3 specs.
      $conv_id = ding_list_convert_cql($ting_object_id);
      // TODO Is the intent here to create a fake DingProviderLoan object?
      // If so why not create an actual instance of the class?
      $loan = new stdClass();
      $loan->ding_entity_id = $conv_id;
      $loans[] = $loan;
    }
  }

  if (!empty($loans)) {
    // Pick max 3 random current loans.
    // TODO Why 3?
    $randoms = (array) array_rand($loans, min(count($loans), 3));

    foreach ($randoms as $random) {
      // TODO Will this work for provider loan lists? ding_entity_id is not
      // a public property for DingProviderLoan.
      $obj = ding_entity_load($loans[$random]->ding_entity_id, 'ting_object');
      if (!empty($obj)) {
        $isbn = $obj->getIsbn();

        if (!empty($isbn)) {
          if (is_array($isbn)) {
            $isbn = current($isbn);
          }
          $recommendations = ting_get_object_recommendations($isbn, 4);

          /**
           * @TODO: Later. Create the ting_object id correct instead of hardcoded
           *        "870970-basis:", but ding_provider_build_entity_id doesn't
           *        work.
           * TODO: Why is this?
           */
          $agency = '870970-basis:';
          if (!empty($recommendations)) {
            // Collect ADHL recommendations to results.
            foreach ($recommendations as $recommendation) {
              $results[] = array(
                'type' => 'ting_object',
                'id' => $agency . $recommendation->localId,
                'info' => array(
                  'adhl' => 'adhl',
                  'description' => t('Because you borrowed !item', array('!item' => l($obj->getTitle(), 'ting/object/' . $obj->getId()))),
                ),
              );
            }
          }
        }
      }
    }
  }
  return $results;
}

/**
 * Find objects matching some random author from the user lists.
 *
 * @param array $context
 *   Serendipity context.
 *
 * @return array
 *   An array with serendipity items.
 */
function ding_serendipity_lists_author_from_lists_serendipity_add($context) {
  if (!isset($context['bundle']) || $context['bundle'] != 'ting_object') {
    return array();
  }

  $terms = array();
  $results = array();

  // Random user list item.
  $ting_entity = ding_list_get_random_user_list_item();
  // Fetch author.
  if ($ting_entity) {
    $author = $ting_entity->getCreators();
    // TODO: How can getCreators return FALSE? It always returns an array.
    if ($author == FALSE) {
      return array();
    }
    // TODO Why is only the first author checked?
    $terms[] = 'facet.creator="' . $author[0] . '"';
    // Taxonomy terms except frontpage has a subject.
    // TODO Please explain why this is added? Does searching directly on the
    // other yield too broad results?
    if ($context['frontpage'] !== "1" && isset($context['taxonomy_tid'])) {
      $term = taxonomy_term_load($context['taxonomy_tid']);

      if (!empty($term->field_search_string)) {
        $terms[] = $term->field_search_string[field_language('taxonomy_term', $term, 'field_search_string')][0]['value'];
      }
      else {
        $terms[] = 'facet.subject="' . $term->name . '"';
      }
    }

    $query = implode(" AND ", $terms);
    // Fetch search results.
    $results = ding_serendipity_do_search($query);
    if ($results) {
      // Append info.
      foreach ($results as & $item) {
        $item['info'] = array(
          'Query' => $query,
          'description' => t('Because you have a list with materials by the author @author.', array('@author' => $author[0])),
        );
      }
    }
  }

  return $results;
}

/**
 * Serendipity contribution.
 *
 * Fetch nodes of type $context['bundle']
 * matching followed terms
 *
 * @param array $context
 *   Serendipity context.
 *
 * @return array
 *   An array with serendipity items.
 */
function ding_serendipity_lists_followed_terms_nodes_serendipity_add($context) {
  global $user;

  // TODO: Why is this not relevant on the frontpage?
  if (!user_is_logged_in() || empty($context['bundle']) || !$context['frontpage']) {
    return array();
  }

  $tids = ding_list_load_keys($user, DING_LIST_TYPE_FOLLOW, 'taxonomy_term');
  $nids = ding_list_tids_to_nids($tids, $context['bundle']);

  $result = array();
  foreach ($nids as $nid) {
    $result[] = array(
      'type' => 'node',
      'id' => $nid,
      'info' => array(
        // TODO If this is reaching the end user then elements like node and term
        // seem too technical?
        'description' => t('This node is displayed because of the terms you are following.'),
      ),
    );
  }

  return $result;
}

/**
 * Serendipity contribution via followed terms.
 *
 * @param array $context
 *   Serendipity context array
 *
 * @return array
 *   An array with serendipity items.
 */
function ding_serendipity_lists_followed_terms_ting_objects_serendipity_add($context) {
  global $user;

  // TODO: Why is this not relevant on the frontpage or on ting_objects?
  if (!user_is_logged_in() || empty($context['bundle']) || $context['bundle'] != 'ting_object' || !$context['frontpage']) {
    return array();
  }

  // Fetch followed terms.
  $tids = ding_list_load_keys($user, DING_LIST_TYPE_FOLLOW, 'taxonomy_term');

  if (count($tids) == 0) {
    return array();
  }

  // Load random term.
  $term = taxonomy_term_load($tids[array_rand($tids)]);
  if ($term) {
    if (!empty($term->field_search_string)) {
      $query = $term->field_search_string[field_language('taxonomy_term', $term, 'field_search_string')][0]['value'];
    }
    else {
      $query = "facet.subject=\"$term->name\"";
    }
  }
  else {
    // TODO Why do we fall back to the frontpage seach if there is no term
    // available? I would expect that we let other serendipity plugins
    // contribute instead.
    if ($search_string = variable_get('ding_frontpage_serendipity_search_string', '')) {
      $query = $search_string;
    }
  }
  // Fetch search results.
  $results = ding_serendipity_do_search(
    $query,
    array(
      'shuffle' => TRUE,
      // TODO Why is 4 the limit here?
      'limit' => 4,
    )
  );

  // Append source info.
  foreach ($results as & $item) {
    $item['info'] = array(
      // TODO: This will fail if a term could not be loaded. See also comment
      // above.
      // TODO: Should term be uppercase here?
      'Term' => $term->name,
      'description' => t('This material is displayed because of the you are following !term.', array('!term' => $term->name)),
    );
  }
  return $results;
}
